[{"name":"All","description":"io.github.nomisRev.kafka.publisher.Acks.All","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/-all/index.html","searchKeys":["All","All","io.github.nomisRev.kafka.publisher.Acks.All"]},{"name":"Earliest","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.Earliest","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/-earliest/index.html","searchKeys":["Earliest","Earliest","io.github.nomisRev.kafka.receiver.AutoOffsetReset.Earliest"]},{"name":"Latest","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.Latest","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/-latest/index.html","searchKeys":["Latest","Latest","io.github.nomisRev.kafka.receiver.AutoOffsetReset.Latest"]},{"name":"MinusOne","description":"io.github.nomisRev.kafka.publisher.Acks.MinusOne","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/-minus-one/index.html","searchKeys":["MinusOne","MinusOne","io.github.nomisRev.kafka.publisher.Acks.MinusOne"]},{"name":"None","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.None","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/-none/index.html","searchKeys":["None","None","io.github.nomisRev.kafka.receiver.AutoOffsetReset.None"]},{"name":"One","description":"io.github.nomisRev.kafka.publisher.Acks.One","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/-one/index.html","searchKeys":["One","One","io.github.nomisRev.kafka.publisher.Acks.One"]},{"name":"Zero","description":"io.github.nomisRev.kafka.publisher.Acks.Zero","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/-zero/index.html","searchKeys":["Zero","Zero","io.github.nomisRev.kafka.publisher.Acks.Zero"]},{"name":"abstract fun position(): Long","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.position","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/position.html","searchKeys":["position","abstract fun position(): Long","io.github.nomisRev.kafka.receiver.ConsumerPartition.position"]},{"name":"abstract fun receive(topicNames: Collection<String>): Flow<ReceiverRecord<K, V>>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver.receive","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/receive.html","searchKeys":["receive","abstract fun receive(topicNames: Collection<String>): Flow<ReceiverRecord<K, V>>","io.github.nomisRev.kafka.receiver.KafkaReceiver.receive"]},{"name":"abstract fun receiveAutoAck(topicNames: Collection<String>): Flow<Flow<ConsumerRecord<K, V>>>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver.receiveAutoAck","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/receive-auto-ack.html","searchKeys":["receiveAutoAck","abstract fun receiveAutoAck(topicNames: Collection<String>): Flow<Flow<ConsumerRecord<K, V>>>","io.github.nomisRev.kafka.receiver.KafkaReceiver.receiveAutoAck"]},{"name":"abstract fun seek(offset: Long)","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.seek","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/seek.html","searchKeys":["seek","abstract fun seek(offset: Long)","io.github.nomisRev.kafka.receiver.ConsumerPartition.seek"]},{"name":"abstract fun seekToBeginning()","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToBeginning","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/seek-to-beginning.html","searchKeys":["seekToBeginning","abstract fun seekToBeginning()","io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToBeginning"]},{"name":"abstract fun seekToEnd()","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToEnd","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/seek-to-end.html","searchKeys":["seekToEnd","abstract fun seekToEnd()","io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToEnd"]},{"name":"abstract fun seekToTimestamp(timestamp: Long)","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToTimestamp","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/seek-to-timestamp.html","searchKeys":["seekToTimestamp","abstract fun seekToTimestamp(timestamp: Long)","io.github.nomisRev.kafka.receiver.ConsumerPartition.seekToTimestamp"]},{"name":"abstract suspend fun <A> publishScope(block: suspend TransactionalScope<Key, Value>.() -> A): A","description":"io.github.nomisRev.kafka.publisher.KafkaPublisher.publishScope","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-kafka-publisher/publish-scope.html","searchKeys":["publishScope","abstract suspend fun <A> publishScope(block: suspend TransactionalScope<Key, Value>.() -> A): A","io.github.nomisRev.kafka.publisher.KafkaPublisher.publishScope"]},{"name":"abstract suspend fun <A> transaction(block: suspend PublishScope<Key, Value>.() -> A): A","description":"io.github.nomisRev.kafka.publisher.TransactionalScope.transaction","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-transactional-scope/transaction.html","searchKeys":["transaction","abstract suspend fun <A> transaction(block: suspend PublishScope<Key, Value>.() -> A): A","io.github.nomisRev.kafka.publisher.TransactionalScope.transaction"]},{"name":"abstract suspend fun <A> withConsumer(action: suspend KafkaConsumer<K, V>.(KafkaConsumer<K, V>) -> A): A","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver.withConsumer","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/with-consumer.html","searchKeys":["withConsumer","abstract suspend fun <A> withConsumer(action: suspend KafkaConsumer<K, V>.(KafkaConsumer<K, V>) -> A): A","io.github.nomisRev.kafka.receiver.KafkaReceiver.withConsumer"]},{"name":"abstract suspend fun acknowledge()","description":"io.github.nomisRev.kafka.receiver.Offset.acknowledge","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-offset/acknowledge.html","searchKeys":["acknowledge","abstract suspend fun acknowledge()","io.github.nomisRev.kafka.receiver.Offset.acknowledge"]},{"name":"abstract suspend fun commit()","description":"io.github.nomisRev.kafka.receiver.Offset.commit","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-offset/commit.html","searchKeys":["commit","abstract suspend fun commit()","io.github.nomisRev.kafka.receiver.Offset.commit"]},{"name":"abstract suspend fun metrics(): Map<MetricName, Metric>","description":"io.github.nomisRev.kafka.publisher.KafkaPublisher.metrics","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-kafka-publisher/metrics.html","searchKeys":["metrics","abstract suspend fun metrics(): Map<MetricName, Metric>","io.github.nomisRev.kafka.publisher.KafkaPublisher.metrics"]},{"name":"abstract suspend fun offer(record: ProducerRecord<Key, Value>)","description":"io.github.nomisRev.kafka.publisher.PublishScope.offer","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/offer.html","searchKeys":["offer","abstract suspend fun offer(record: ProducerRecord<Key, Value>)","io.github.nomisRev.kafka.publisher.PublishScope.offer"]},{"name":"abstract suspend fun partitionsFor(topic: String): List<PartitionInfo>","description":"io.github.nomisRev.kafka.publisher.KafkaPublisher.partitionsFor","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-kafka-publisher/partitions-for.html","searchKeys":["partitionsFor","abstract suspend fun partitionsFor(topic: String): List<PartitionInfo>","io.github.nomisRev.kafka.publisher.KafkaPublisher.partitionsFor"]},{"name":"abstract suspend fun publish(record: ProducerRecord<Key, Value>): RecordMetadata","description":"io.github.nomisRev.kafka.publisher.PublishScope.publish","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/publish.html","searchKeys":["publish","abstract suspend fun publish(record: ProducerRecord<Key, Value>): RecordMetadata","io.github.nomisRev.kafka.publisher.PublishScope.publish"]},{"name":"abstract suspend fun publishCatching(record: Iterable<ProducerRecord<Key, Value>>): Result<List<RecordMetadata>>","description":"io.github.nomisRev.kafka.publisher.PublishScope.publishCatching","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/publish-catching.html","searchKeys":["publishCatching","abstract suspend fun publishCatching(record: Iterable<ProducerRecord<Key, Value>>): Result<List<RecordMetadata>>","io.github.nomisRev.kafka.publisher.PublishScope.publishCatching"]},{"name":"abstract suspend fun publishCatching(record: ProducerRecord<Key, Value>): Result<RecordMetadata>","description":"io.github.nomisRev.kafka.publisher.PublishScope.publishCatching","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/publish-catching.html","searchKeys":["publishCatching","abstract suspend fun publishCatching(record: ProducerRecord<Key, Value>): Result<RecordMetadata>","io.github.nomisRev.kafka.publisher.PublishScope.publishCatching"]},{"name":"abstract val offset: Long","description":"io.github.nomisRev.kafka.receiver.Offset.offset","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-offset/offset.html","searchKeys":["offset","abstract val offset: Long","io.github.nomisRev.kafka.receiver.Offset.offset"]},{"name":"abstract val topicPartition: TopicPartition","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition.topicPartition","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/topic-partition.html","searchKeys":["topicPartition","abstract val topicPartition: TopicPartition","io.github.nomisRev.kafka.receiver.ConsumerPartition.topicPartition"]},{"name":"abstract val topicPartition: TopicPartition","description":"io.github.nomisRev.kafka.receiver.Offset.topicPartition","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-offset/topic-partition.html","searchKeys":["topicPartition","abstract val topicPartition: TopicPartition","io.github.nomisRev.kafka.receiver.Offset.topicPartition"]},{"name":"annotation class PublisherDSL","description":"io.github.nomisRev.kafka.publisher.PublisherDSL","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-d-s-l/index.html","searchKeys":["PublisherDSL","annotation class PublisherDSL","io.github.nomisRev.kafka.publisher.PublisherDSL"]},{"name":"class ReceiverRecord<K, V>(record: ConsumerRecord<K, V>, val offset: Offset) : ConsumerRecord<K, V> ","description":"io.github.nomisRev.kafka.receiver.ReceiverRecord","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-record/index.html","searchKeys":["ReceiverRecord","class ReceiverRecord<K, V>(record: ConsumerRecord<K, V>, val offset: Offset) : ConsumerRecord<K, V> ","io.github.nomisRev.kafka.receiver.ReceiverRecord"]},{"name":"constructor(bootstrapServer: String, props: Properties? = null)","description":"io.github.nomisRev.kafka.AdminSettings.AdminSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/-admin-settings.html","searchKeys":["AdminSettings","constructor(bootstrapServer: String, props: Properties? = null)","io.github.nomisRev.kafka.AdminSettings.AdminSettings"]},{"name":"constructor(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, maxDeferredCommits: Int = 0, closeTimeout: Duration = Duration.INFINITE, properties: Properties = Properties())","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.ReceiverSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/-receiver-settings.html","searchKeys":["ReceiverSettings","constructor(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, maxDeferredCommits: Int = 0, closeTimeout: Duration = Duration.INFINITE, properties: Properties = Properties())","io.github.nomisRev.kafka.receiver.ReceiverSettings.ReceiverSettings"]},{"name":"constructor(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, sessionTimeOut: Duration = Duration.ofMillis(10000), heartbeatInterval: Duration = Duration.ofMillis(3000), autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), metadataMaxAge: Long = (5 * 60 * 1000).toLong(), enableAutoCommit: Boolean = true, autoCommitInterval: Duration = Duration.ofMillis(5000), clientId: String = \"\", maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, sendBuffer: Int = 128 * 1024, receiveBuffer: Int = 64 * 1024, fetchMinBytes: Int = 1, fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, fetchMaxWait: Duration = Duration.ofMillis(500), reconnectBackoff: Duration = Duration.ofMillis(50L), reconnectBackoffMax: Duration = Duration.ofMillis(1000), retryBackoff: Duration = Duration.ofMillis(100), checkCrcs: Boolean = true, metricsSampleWindow: Duration = Duration.ofMillis(30000), metricsNumSamples: Int = 2, metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, metricsReporterClasses: List<Class<*>> = emptyList(), requestTimeout: Duration = Duration.ofMillis(30000), defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), interceptorClasses: List<Class<*>> = emptyList(), maxPollRecords: Int = 500, maxPollInterval: Duration = Duration.ofMillis(300_000), excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","description":"io.github.nomisRev.kafka.ConsumerSettings.ConsumerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/-consumer-settings.html","searchKeys":["ConsumerSettings","constructor(bootstrapServers: String, keyDeserializer: Deserializer<K>, valueDeserializer: Deserializer<V>, groupId: String, clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, sessionTimeOut: Duration = Duration.ofMillis(10000), heartbeatInterval: Duration = Duration.ofMillis(3000), autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), metadataMaxAge: Long = (5 * 60 * 1000).toLong(), enableAutoCommit: Boolean = true, autoCommitInterval: Duration = Duration.ofMillis(5000), clientId: String = \"\", maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, sendBuffer: Int = 128 * 1024, receiveBuffer: Int = 64 * 1024, fetchMinBytes: Int = 1, fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, fetchMaxWait: Duration = Duration.ofMillis(500), reconnectBackoff: Duration = Duration.ofMillis(50L), reconnectBackoffMax: Duration = Duration.ofMillis(1000), retryBackoff: Duration = Duration.ofMillis(100), checkCrcs: Boolean = true, metricsSampleWindow: Duration = Duration.ofMillis(30000), metricsNumSamples: Int = 2, metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, metricsReporterClasses: List<Class<*>> = emptyList(), requestTimeout: Duration = Duration.ofMillis(30000), defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), interceptorClasses: List<Class<*>> = emptyList(), maxPollRecords: Int = 500, maxPollInterval: Duration = Duration.ofMillis(300_000), excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","io.github.nomisRev.kafka.ConsumerSettings.ConsumerSettings"]},{"name":"constructor(bootstrapServers: String, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>, acks: Acks = Acks.One, other: Properties? = null)","description":"io.github.nomisRev.kafka.ProducerSettings.ProducerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/-producer-settings.html","searchKeys":["ProducerSettings","constructor(bootstrapServers: String, keyDeserializer: Serializer<K>, valueDeserializer: Serializer<V>, acks: Acks = Acks.One, other: Properties? = null)","io.github.nomisRev.kafka.ProducerSettings.ProducerSettings"]},{"name":"constructor(bootstrapServers: String, keySerializer: Serializer<Key>, valueSerializer: Serializer<Value>, acknowledgments: Acks = Acks.One, closeTimeout: Duration = Duration.INFINITE, isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, properties: Properties = Properties())","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.PublisherSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/-publisher-settings.html","searchKeys":["PublisherSettings","constructor(bootstrapServers: String, keySerializer: Serializer<Key>, valueSerializer: Serializer<Value>, acknowledgments: Acks = Acks.One, closeTimeout: Duration = Duration.INFINITE, isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, properties: Properties = Properties())","io.github.nomisRev.kafka.publisher.PublisherSettings.PublisherSettings"]},{"name":"constructor(interval: Duration)","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime.ByTime","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-time/-by-time.html","searchKeys":["ByTime","constructor(interval: Duration)","io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime.ByTime"]},{"name":"constructor(record: ConsumerRecord<K, V>, offset: Offset)","description":"io.github.nomisRev.kafka.receiver.ReceiverRecord.ReceiverRecord","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-record/-receiver-record.html","searchKeys":["ReceiverRecord","constructor(record: ConsumerRecord<K, V>, offset: Offset)","io.github.nomisRev.kafka.receiver.ReceiverRecord.ReceiverRecord"]},{"name":"constructor(size: Int)","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySize.BySize","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size/-by-size.html","searchKeys":["BySize","constructor(size: Int)","io.github.nomisRev.kafka.receiver.CommitStrategy.BySize.BySize"]},{"name":"constructor(size: Int, interval: Duration)","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.BySizeOrTime","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size-or-time/-by-size-or-time.html","searchKeys":["BySizeOrTime","constructor(size: Int, interval: Duration)","io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.BySizeOrTime"]},{"name":"data class AdminSettings(val bootstrapServer: String, props: Properties? = null)","description":"io.github.nomisRev.kafka.AdminSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/index.html","searchKeys":["AdminSettings","data class AdminSettings(val bootstrapServer: String, props: Properties? = null)","io.github.nomisRev.kafka.AdminSettings"]},{"name":"data class BySizeOrTime(val size: Int, val interval: Duration) : CommitStrategy","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size-or-time/index.html","searchKeys":["BySizeOrTime","data class BySizeOrTime(val size: Int, val interval: Duration) : CommitStrategy","io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime"]},{"name":"data class ConsumerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, val sessionTimeOut: Duration = Duration.ofMillis(10000), val heartbeatInterval: Duration = Duration.ofMillis(3000), val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, val partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), val metadataMaxAge: Long = (5 * 60 * 1000).toLong(), val enableAutoCommit: Boolean = true, val autoCommitInterval: Duration = Duration.ofMillis(5000), val clientId: String = \"\", val maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, val sendBuffer: Int = 128 * 1024, val receiveBuffer: Int = 64 * 1024, val fetchMinBytes: Int = 1, val fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, val fetchMaxWait: Duration = Duration.ofMillis(500), val reconnectBackoff: Duration = Duration.ofMillis(50L), val reconnectBackoffMax: Duration = Duration.ofMillis(1000), val retryBackoff: Duration = Duration.ofMillis(100), val checkCrcs: Boolean = true, val metricsSampleWindow: Duration = Duration.ofMillis(30000), val metricsNumSamples: Int = 2, val metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, val metricsReporterClasses: List<Class<*>> = emptyList(), val requestTimeout: Duration = Duration.ofMillis(30000), val defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), val connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), val interceptorClasses: List<Class<*>> = emptyList(), val maxPollRecords: Int = 500, val maxPollInterval: Duration = Duration.ofMillis(300_000), val excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","description":"io.github.nomisRev.kafka.ConsumerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/index.html","searchKeys":["ConsumerSettings","data class ConsumerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val clientDnsLookup: ClientDnsLookup = ClientDnsLookup.USE_ALL_DNS_IPS, val sessionTimeOut: Duration = Duration.ofMillis(10000), val heartbeatInterval: Duration = Duration.ofMillis(3000), val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Latest, val partitionAssignmentStrategy: List<Class<*>> = listOf(RangeAssignor::class.java), val metadataMaxAge: Long = (5 * 60 * 1000).toLong(), val enableAutoCommit: Boolean = true, val autoCommitInterval: Duration = Duration.ofMillis(5000), val clientId: String = \"\", val maxPartitionFetchBytes: Int = DEFAULT_MAX_PARTITION_FETCH_BYTES, val sendBuffer: Int = 128 * 1024, val receiveBuffer: Int = 64 * 1024, val fetchMinBytes: Int = 1, val fetchMaxBytes: Int = ConsumerConfig.DEFAULT_FETCH_MAX_BYTES, val fetchMaxWait: Duration = Duration.ofMillis(500), val reconnectBackoff: Duration = Duration.ofMillis(50L), val reconnectBackoffMax: Duration = Duration.ofMillis(1000), val retryBackoff: Duration = Duration.ofMillis(100), val checkCrcs: Boolean = true, val metricsSampleWindow: Duration = Duration.ofMillis(30000), val metricsNumSamples: Int = 2, val metricsRecordingLevel: Sensor.RecordingLevel = Sensor.RecordingLevel.INFO, val metricsReporterClasses: List<Class<*>> = emptyList(), val requestTimeout: Duration = Duration.ofMillis(30000), val defaultApiTimeout: Duration = Duration.ofMillis(60 * 1000), val connectionsMaxIdle: Duration = Duration.ofMillis(9 * 60 * 1000), val interceptorClasses: List<Class<*>> = emptyList(), val maxPollRecords: Int = 500, val maxPollInterval: Duration = Duration.ofMillis(300_000), val excludeInternalTopics: Boolean = ConsumerConfig.DEFAULT_EXCLUDE_INTERNAL_TOPICS, properties: Properties? = null)","io.github.nomisRev.kafka.ConsumerSettings"]},{"name":"data class ProducerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Serializer<K>, val valueDeserializer: Serializer<V>, val acks: Acks = Acks.One, val other: Properties? = null)","description":"io.github.nomisRev.kafka.ProducerSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/index.html","searchKeys":["ProducerSettings","data class ProducerSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Serializer<K>, val valueDeserializer: Serializer<V>, val acks: Acks = Acks.One, val other: Properties? = null)","io.github.nomisRev.kafka.ProducerSettings"]},{"name":"data class PublisherSettings<Key, Value>(val bootstrapServers: String, val keySerializer: Serializer<Key>, val valueSerializer: Serializer<Value>, val acknowledgments: Acks = Acks.One, val closeTimeout: Duration = Duration.INFINITE, val isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, val producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, val onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, val createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, val properties: Properties = Properties())","description":"io.github.nomisRev.kafka.publisher.PublisherSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/index.html","searchKeys":["PublisherSettings","data class PublisherSettings<Key, Value>(val bootstrapServers: String, val keySerializer: Serializer<Key>, val valueSerializer: Serializer<Value>, val acknowledgments: Acks = Acks.One, val closeTimeout: Duration = Duration.INFINITE, val isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, val producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, val onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, val createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, val properties: Properties = Properties())","io.github.nomisRev.kafka.publisher.PublisherSettings"]},{"name":"data class ReceiverSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, val commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), val pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, val commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, val maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, val maxDeferredCommits: Int = 0, val closeTimeout: Duration = Duration.INFINITE, val properties: Properties = Properties())","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/index.html","searchKeys":["ReceiverSettings","data class ReceiverSettings<K, V>(val bootstrapServers: String, val keyDeserializer: Deserializer<K>, val valueDeserializer: Deserializer<V>, val groupId: String, val autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, val commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), val pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, val commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, val maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, val maxDeferredCommits: Int = 0, val closeTimeout: Duration = Duration.INFINITE, val properties: Properties = Properties())","io.github.nomisRev.kafka.receiver.ReceiverSettings"]},{"name":"enum Acks : Enum<Acks> ","description":"io.github.nomisRev.kafka.publisher.Acks","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/index.html","searchKeys":["Acks","enum Acks : Enum<Acks> ","io.github.nomisRev.kafka.publisher.Acks"]},{"name":"enum AutoOffsetReset : Enum<AutoOffsetReset> ","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/index.html","searchKeys":["AutoOffsetReset","enum AutoOffsetReset : Enum<AutoOffsetReset> ","io.github.nomisRev.kafka.receiver.AutoOffsetReset"]},{"name":"fun <A : Closeable> A.asFlow(): Flow<A>","description":"io.github.nomisRev.kafka.asFlow","location":"kotlin-kafka/io.github.nomisRev.kafka/as-flow.html","searchKeys":["asFlow","fun <A : Closeable> A.asFlow(): Flow<A>","io.github.nomisRev.kafka.asFlow"]},{"name":"fun <A, B> Deserializer<A>.map(f: (A) -> B): Deserializer<B>","description":"io.github.nomisRev.kafka.map","location":"kotlin-kafka/io.github.nomisRev.kafka/map.html","searchKeys":["map","fun <A, B> Deserializer<A>.map(f: (A) -> B): Deserializer<B>","io.github.nomisRev.kafka.map"]},{"name":"fun <A, B> Flow<ProducerRecord<A, B>>.produce(settings: ProducerSettings<A, B>): Flow<RecordMetadata>","description":"io.github.nomisRev.kafka.produce","location":"kotlin-kafka/io.github.nomisRev.kafka/produce.html","searchKeys":["produce","fun <A, B> Flow<ProducerRecord<A, B>>.produce(settings: ProducerSettings<A, B>): Flow<RecordMetadata>","io.github.nomisRev.kafka.produce"]},{"name":"fun <A, B> Serializer<A>.imap(f: (B) -> A): Serializer<B>","description":"io.github.nomisRev.kafka.imap","location":"kotlin-kafka/io.github.nomisRev.kafka/imap.html","searchKeys":["imap","fun <A, B> Serializer<A>.imap(f: (B) -> A): Serializer<B>","io.github.nomisRev.kafka.imap"]},{"name":"fun <K, V> ConsumerRecord<K, V>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> ConsumerRecord<K, V>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> Flow<ConsumerRecord<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Unit>","description":"io.github.nomisRev.kafka.commitBatchWithin","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-batch-within.html","searchKeys":["commitBatchWithin","fun <K, V> Flow<ConsumerRecord<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Unit>","io.github.nomisRev.kafka.commitBatchWithin"]},{"name":"fun <K, V> Flow<ConsumerRecords<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Map<TopicPartition, OffsetAndMetadata>>","description":"io.github.nomisRev.kafka.commitBatchWithin","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-batch-within.html","searchKeys":["commitBatchWithin","fun <K, V> Flow<ConsumerRecords<K, V>>.commitBatchWithin(settings: ConsumerSettings<K, V>, count: Int, duration: Duration, metadata: (record: ConsumerRecord<K, V>) -> String? = null): Flow<Map<TopicPartition, OffsetAndMetadata>>","io.github.nomisRev.kafka.commitBatchWithin"]},{"name":"fun <K, V> Flow<KafkaConsumer<K, V>>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener, timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","description":"io.github.nomisRev.kafka.subscribeTo","location":"kotlin-kafka/io.github.nomisRev.kafka/subscribe-to.html","searchKeys":["subscribeTo","fun <K, V> Flow<KafkaConsumer<K, V>>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener, timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","io.github.nomisRev.kafka.subscribeTo"]},{"name":"fun <K, V> Iterable<ConsumerRecord<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> Iterable<ConsumerRecord<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> KafkaConsumer(settings: ConsumerSettings<K, V>): KafkaConsumer<K, V>","description":"io.github.nomisRev.kafka.KafkaConsumer","location":"kotlin-kafka/io.github.nomisRev.kafka/-kafka-consumer.html","searchKeys":["KafkaConsumer","fun <K, V> KafkaConsumer(settings: ConsumerSettings<K, V>): KafkaConsumer<K, V>","io.github.nomisRev.kafka.KafkaConsumer"]},{"name":"fun <K, V> KafkaConsumer<K, V>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener, timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","description":"io.github.nomisRev.kafka.subscribeTo","location":"kotlin-kafka/io.github.nomisRev.kafka/subscribe-to.html","searchKeys":["subscribeTo","fun <K, V> KafkaConsumer<K, V>.subscribeTo(name: String, dispatcher: CoroutineDispatcher = IO, listener: ConsumerRebalanceListener = NoOpConsumerRebalanceListener, timeout: Duration = 500.milliseconds): Flow<ConsumerRecord<K, V>>","io.github.nomisRev.kafka.subscribeTo"]},{"name":"fun <K, V> KafkaProducer(setting: ProducerSettings<K, V>): KafkaProducer<K, V>","description":"io.github.nomisRev.kafka.KafkaProducer","location":"kotlin-kafka/io.github.nomisRev.kafka/-kafka-producer.html","searchKeys":["KafkaProducer","fun <K, V> KafkaProducer(setting: ProducerSettings<K, V>): KafkaProducer<K, V>","io.github.nomisRev.kafka.KafkaProducer"]},{"name":"fun <K, V> KafkaReceiver(settings: ReceiverSettings<K, V>): KafkaReceiver<K, V>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver.html","searchKeys":["KafkaReceiver","fun <K, V> KafkaReceiver(settings: ReceiverSettings<K, V>): KafkaReceiver<K, V>","io.github.nomisRev.kafka.receiver.KafkaReceiver"]},{"name":"fun <K, V> List<ConsumerRecords<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.offsets","location":"kotlin-kafka/io.github.nomisRev.kafka/offsets.html","searchKeys":["offsets","fun <K, V> List<ConsumerRecords<K, V>>.offsets(metadata: (record: ConsumerRecord<K, V>) -> String? = null): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.offsets"]},{"name":"fun <K, V> kafkaConsumer(settings: ConsumerSettings<K, V>): Flow<KafkaConsumer<K, V>>","description":"io.github.nomisRev.kafka.kafkaConsumer","location":"kotlin-kafka/io.github.nomisRev.kafka/kafka-consumer.html","searchKeys":["kafkaConsumer","fun <K, V> kafkaConsumer(settings: ConsumerSettings<K, V>): Flow<KafkaConsumer<K, V>>","io.github.nomisRev.kafka.kafkaConsumer"]},{"name":"fun <K, V> kafkaProducer(setting: ProducerSettings<K, V>): Flow<KafkaProducer<K, V>>","description":"io.github.nomisRev.kafka.kafkaProducer","location":"kotlin-kafka/io.github.nomisRev.kafka/kafka-producer.html","searchKeys":["kafkaProducer","fun <K, V> kafkaProducer(setting: ProducerSettings<K, V>): Flow<KafkaProducer<K, V>>","io.github.nomisRev.kafka.kafkaProducer"]},{"name":"fun <Key, Value> Flow<ProducerRecord<Key, Value>>.produce(settings: PublisherSettings<Key, Value>, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit? = null, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): Flow<Result<RecordMetadata>>","description":"io.github.nomisRev.kafka.publisher.produce","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/produce.html","searchKeys":["produce","fun <Key, Value> Flow<ProducerRecord<Key, Value>>.produce(settings: PublisherSettings<Key, Value>, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit? = null, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): Flow<Result<RecordMetadata>>","io.github.nomisRev.kafka.publisher.produce"]},{"name":"fun <Key, Value> Flow<ProducerRecord<Key, Value>>.produceOrThrow(settings: PublisherSettings<Key, Value>, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit? = null, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): Flow<RecordMetadata>","description":"io.github.nomisRev.kafka.publisher.produceOrThrow","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/produce-or-throw.html","searchKeys":["produceOrThrow","fun <Key, Value> Flow<ProducerRecord<Key, Value>>.produceOrThrow(settings: PublisherSettings<Key, Value>, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit? = null, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): Flow<RecordMetadata>","io.github.nomisRev.kafka.publisher.produceOrThrow"]},{"name":"fun <Key, Value> KafkaPublisher(settings: PublisherSettings<Key, Value>, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): KafkaPublisher<Key, Value>","description":"io.github.nomisRev.kafka.publisher.KafkaPublisher","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-kafka-publisher.html","searchKeys":["KafkaPublisher","fun <Key, Value> KafkaPublisher(settings: PublisherSettings<Key, Value>, createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>? = null): KafkaPublisher<Key, Value>","io.github.nomisRev.kafka.publisher.KafkaPublisher"]},{"name":"fun <T> KafkaFuture<T>.asDeferred(): Deferred<T>","description":"io.github.nomisRev.kafka.asDeferred","location":"kotlin-kafka/io.github.nomisRev.kafka/as-deferred.html","searchKeys":["asDeferred","fun <T> KafkaFuture<T>.asDeferred(): Deferred<T>","io.github.nomisRev.kafka.asDeferred"]},{"name":"fun <V> ReceiverSettings(bootstrapServers: String, valueDeserializer: Deserializer<V>, groupId: String, autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, maxDeferredCommits: Int = 0, closeTimeout: Duration = Long.MAX_VALUE.nanoseconds, properties: Properties = Properties()): ReceiverSettings<Nothing, V>","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings.html","searchKeys":["ReceiverSettings","fun <V> ReceiverSettings(bootstrapServers: String, valueDeserializer: Deserializer<V>, groupId: String, autoOffsetReset: AutoOffsetReset = AutoOffsetReset.Earliest, commitStrategy: CommitStrategy = CommitStrategy.ByTime(DEFAULT_COMMIT_INTERVAL), pollTimeout: Duration = DEFAULT_POLL_TIMEOUT, commitRetryInterval: Duration = DEFAULT_COMMIT_RETRY_INTERVAL, maxCommitAttempts: Int = DEFAULT_MAX_COMMIT_ATTEMPTS, maxDeferredCommits: Int = 0, closeTimeout: Duration = Long.MAX_VALUE.nanoseconds, properties: Properties = Properties()): ReceiverSettings<Nothing, V>","io.github.nomisRev.kafka.receiver.ReceiverSettings"]},{"name":"fun <Value> PublisherSettings(bootstrapServers: String, valueSerializer: Serializer<Value>, acknowledgments: Acks = Acks.All, closeTimeout: Duration = Duration.INFINITE, isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Nothing, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, createProducer: suspend (PublisherSettings<Nothing, Value>) -> Producer<Nothing, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, properties: Properties = Properties()): PublisherSettings<Nothing, Value>","description":"io.github.nomisRev.kafka.publisher.PublisherSettings","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings.html","searchKeys":["PublisherSettings","fun <Value> PublisherSettings(bootstrapServers: String, valueSerializer: Serializer<Value>, acknowledgments: Acks = Acks.All, closeTimeout: Duration = Duration.INFINITE, isFatal: (t: Throwable) -> Boolean = { it is AuthenticationException || it is ProducerFencedException }, producerListener: PublisherSettings.ProducerListener = NoOpProducerListener, onPublisherRecordDropped: suspend (Logger, ProducerRecord<Nothing, Value>) -> Unit = { logger, record -> logger.debug(\"ProducerRecord Dropped: {}\", record) }, createProducer: suspend (PublisherSettings<Nothing, Value>) -> Producer<Nothing, Value> = { settings -> KafkaProducer(settings.properties(), settings.keySerializer, settings.valueSerializer) }, properties: Properties = Properties()): PublisherSettings<Nothing, Value>","io.github.nomisRev.kafka.publisher.PublisherSettings"]},{"name":"fun Admin(settings: AdminSettings): Admin","description":"io.github.nomisRev.kafka.Admin","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin.html","searchKeys":["Admin","fun Admin(settings: AdminSettings): Admin","io.github.nomisRev.kafka.Admin"]},{"name":"fun isTransactional(): Boolean","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.isTransactional","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/is-transactional.html","searchKeys":["isTransactional","fun isTransactional(): Boolean","io.github.nomisRev.kafka.publisher.PublisherSettings.isTransactional"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.AdminSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.AdminSettings.properties"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.ConsumerSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.ConsumerSettings.properties"]},{"name":"fun properties(): Properties","description":"io.github.nomisRev.kafka.ProducerSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/properties.html","searchKeys":["properties","fun properties(): Properties","io.github.nomisRev.kafka.ProducerSettings.properties"]},{"name":"fun toPublisherSettings(): PublisherSettings<K, V>","description":"io.github.nomisRev.kafka.ProducerSettings.toPublisherSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/to-publisher-settings.html","searchKeys":["toPublisherSettings","fun toPublisherSettings(): PublisherSettings<K, V>","io.github.nomisRev.kafka.ProducerSettings.toPublisherSettings"]},{"name":"fun toReceiverSettings(): ReceiverSettings<K, V>","description":"io.github.nomisRev.kafka.ConsumerSettings.toReceiverSettings","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/to-receiver-settings.html","searchKeys":["toReceiverSettings","fun toReceiverSettings(): ReceiverSettings<K, V>","io.github.nomisRev.kafka.ConsumerSettings.toReceiverSettings"]},{"name":"fun transactionalId(): String?","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.transactionalId","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/transactional-id.html","searchKeys":["transactionalId","fun transactionalId(): String?","io.github.nomisRev.kafka.publisher.PublisherSettings.transactionalId"]},{"name":"fun valueOf(value: String): Acks","description":"io.github.nomisRev.kafka.publisher.Acks.valueOf","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/value-of.html","searchKeys":["valueOf","fun valueOf(value: String): Acks","io.github.nomisRev.kafka.publisher.Acks.valueOf"]},{"name":"fun valueOf(value: String): AutoOffsetReset","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.valueOf","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/value-of.html","searchKeys":["valueOf","fun valueOf(value: String): AutoOffsetReset","io.github.nomisRev.kafka.receiver.AutoOffsetReset.valueOf"]},{"name":"fun values(): Array<Acks>","description":"io.github.nomisRev.kafka.publisher.Acks.values","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/values.html","searchKeys":["values","fun values(): Array<Acks>","io.github.nomisRev.kafka.publisher.Acks.values"]},{"name":"fun values(): Array<AutoOffsetReset>","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.values","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/values.html","searchKeys":["values","fun values(): Array<AutoOffsetReset>","io.github.nomisRev.kafka.receiver.AutoOffsetReset.values"]},{"name":"interface ConsumerPartition","description":"io.github.nomisRev.kafka.receiver.ConsumerPartition","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-consumer-partition/index.html","searchKeys":["ConsumerPartition","interface ConsumerPartition","io.github.nomisRev.kafka.receiver.ConsumerPartition"]},{"name":"interface KafkaPublisher<Key, Value> : AutoCloseable","description":"io.github.nomisRev.kafka.publisher.KafkaPublisher","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-kafka-publisher/index.html","searchKeys":["KafkaPublisher","interface KafkaPublisher<Key, Value> : AutoCloseable","io.github.nomisRev.kafka.publisher.KafkaPublisher"]},{"name":"interface KafkaReceiver<K, V>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/index.html","searchKeys":["KafkaReceiver","interface KafkaReceiver<K, V>","io.github.nomisRev.kafka.receiver.KafkaReceiver"]},{"name":"interface Offset","description":"io.github.nomisRev.kafka.receiver.Offset","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-offset/index.html","searchKeys":["Offset","interface Offset","io.github.nomisRev.kafka.receiver.Offset"]},{"name":"interface ProducerListener","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/-producer-listener/index.html","searchKeys":["ProducerListener","interface ProducerListener","io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener"]},{"name":"interface PublishScope<Key, Value> : CoroutineScope","description":"io.github.nomisRev.kafka.publisher.PublishScope","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/index.html","searchKeys":["PublishScope","interface PublishScope<Key, Value> : CoroutineScope","io.github.nomisRev.kafka.publisher.PublishScope"]},{"name":"interface TransactionalScope<Key, Value> : PublishScope<Key, Value> ","description":"io.github.nomisRev.kafka.publisher.TransactionalScope","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-transactional-scope/index.html","searchKeys":["TransactionalScope","interface TransactionalScope<Key, Value> : PublishScope<Key, Value> ","io.github.nomisRev.kafka.publisher.TransactionalScope"]},{"name":"object NothingDeserializer : Deserializer<Nothing> ","description":"io.github.nomisRev.kafka.NothingDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/index.html","searchKeys":["NothingDeserializer","object NothingDeserializer : Deserializer<Nothing> ","io.github.nomisRev.kafka.NothingDeserializer"]},{"name":"object NothingSerializer : Serializer<Nothing> ","description":"io.github.nomisRev.kafka.NothingSerializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/index.html","searchKeys":["NothingSerializer","object NothingSerializer : Serializer<Nothing> ","io.github.nomisRev.kafka.NothingSerializer"]},{"name":"open fun producerAdded(id: String, producer: Producer<*, *>)","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener.producerAdded","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/-producer-listener/producer-added.html","searchKeys":["producerAdded","open fun producerAdded(id: String, producer: Producer<*, *>)","io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener.producerAdded"]},{"name":"open fun producerRemoved(id: String, producer: Producer<*, *>)","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener.producerRemoved","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/-producer-listener/producer-removed.html","searchKeys":["producerRemoved","open fun producerRemoved(id: String, producer: Producer<*, *>)","io.github.nomisRev.kafka.publisher.PublisherSettings.ProducerListener.producerRemoved"]},{"name":"open fun receive(topicName: String): Flow<ReceiverRecord<K, V>>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver.receive","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/receive.html","searchKeys":["receive","open fun receive(topicName: String): Flow<ReceiverRecord<K, V>>","io.github.nomisRev.kafka.receiver.KafkaReceiver.receive"]},{"name":"open fun receiveAutoAck(topicNames: String): Flow<Flow<ConsumerRecord<K, V>>>","description":"io.github.nomisRev.kafka.receiver.KafkaReceiver.receiveAutoAck","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-kafka-receiver/receive-auto-ack.html","searchKeys":["receiveAutoAck","open fun receiveAutoAck(topicNames: String): Flow<Flow<ConsumerRecord<K, V>>>","io.github.nomisRev.kafka.receiver.KafkaReceiver.receiveAutoAck"]},{"name":"open override fun close()","description":"io.github.nomisRev.kafka.NothingDeserializer.close","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/close.html","searchKeys":["close","open override fun close()","io.github.nomisRev.kafka.NothingDeserializer.close"]},{"name":"open override fun close()","description":"io.github.nomisRev.kafka.NothingSerializer.close","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/close.html","searchKeys":["close","open override fun close()","io.github.nomisRev.kafka.NothingSerializer.close"]},{"name":"open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","description":"io.github.nomisRev.kafka.NothingDeserializer.configure","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/configure.html","searchKeys":["configure","open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","io.github.nomisRev.kafka.NothingDeserializer.configure"]},{"name":"open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","description":"io.github.nomisRev.kafka.NothingSerializer.configure","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/configure.html","searchKeys":["configure","open override fun configure(configs: MutableMap<String, *>?, isKey: Boolean)","io.github.nomisRev.kafka.NothingSerializer.configure"]},{"name":"open override fun deserialize(topic: String?, data: ByteArray?): Nothing","description":"io.github.nomisRev.kafka.NothingDeserializer.deserialize","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-deserializer/deserialize.html","searchKeys":["deserialize","open override fun deserialize(topic: String?, data: ByteArray?): Nothing","io.github.nomisRev.kafka.NothingDeserializer.deserialize"]},{"name":"open override fun serialize(topic: String?, data: Nothing?): ByteArray","description":"io.github.nomisRev.kafka.NothingSerializer.serialize","location":"kotlin-kafka/io.github.nomisRev.kafka/-nothing-serializer/serialize.html","searchKeys":["serialize","open override fun serialize(topic: String?, data: Nothing?): ByteArray","io.github.nomisRev.kafka.NothingSerializer.serialize"]},{"name":"open suspend fun offer(records: Iterable<ProducerRecord<Key, Value>>)","description":"io.github.nomisRev.kafka.publisher.PublishScope.offer","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/offer.html","searchKeys":["offer","open suspend fun offer(records: Iterable<ProducerRecord<Key, Value>>)","io.github.nomisRev.kafka.publisher.PublishScope.offer"]},{"name":"open suspend fun publish(record: Iterable<ProducerRecord<Key, Value>>): List<RecordMetadata>","description":"io.github.nomisRev.kafka.publisher.PublishScope.publish","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publish-scope/publish.html","searchKeys":["publish","open suspend fun publish(record: Iterable<ProducerRecord<Key, Value>>): List<RecordMetadata>","io.github.nomisRev.kafka.publisher.PublishScope.publish"]},{"name":"operator fun <K, V> ConsumerRecord<K, V>.component1(): K","description":"io.github.nomisRev.kafka.component1","location":"kotlin-kafka/io.github.nomisRev.kafka/component1.html","searchKeys":["component1","operator fun <K, V> ConsumerRecord<K, V>.component1(): K","io.github.nomisRev.kafka.component1"]},{"name":"operator fun <K, V> ConsumerRecord<K, V>.component2(): V","description":"io.github.nomisRev.kafka.component2","location":"kotlin-kafka/io.github.nomisRev.kafka/component2.html","searchKeys":["component2","operator fun <K, V> ConsumerRecord<K, V>.component2(): V","io.github.nomisRev.kafka.component2"]},{"name":"operator fun <K, V> ProducerRecord<K, V>.component1(): K","description":"io.github.nomisRev.kafka.component1","location":"kotlin-kafka/io.github.nomisRev.kafka/component1.html","searchKeys":["component1","operator fun <K, V> ProducerRecord<K, V>.component1(): K","io.github.nomisRev.kafka.component1"]},{"name":"operator fun <K, V> ProducerRecord<K, V>.component2(): V","description":"io.github.nomisRev.kafka.component2","location":"kotlin-kafka/io.github.nomisRev.kafka/component2.html","searchKeys":["component2","operator fun <K, V> ProducerRecord<K, V>.component2(): V","io.github.nomisRev.kafka.component2"]},{"name":"sealed interface CommitStrategy","description":"io.github.nomisRev.kafka.receiver.CommitStrategy","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/index.html","searchKeys":["CommitStrategy","sealed interface CommitStrategy","io.github.nomisRev.kafka.receiver.CommitStrategy"]},{"name":"suspend fun <A, B> KafkaProducer<A, B>.sendAwait(record: ProducerRecord<A, B>): RecordMetadata","description":"io.github.nomisRev.kafka.sendAwait","location":"kotlin-kafka/io.github.nomisRev.kafka/send-await.html","searchKeys":["sendAwait","suspend fun <A, B> KafkaProducer<A, B>.sendAwait(record: ProducerRecord<A, B>): RecordMetadata","io.github.nomisRev.kafka.sendAwait"]},{"name":"suspend fun <K, V> KafkaConsumer<K, V>.commitAwait(offsets: Map<TopicPartition, OffsetAndMetadata>): Map<TopicPartition, OffsetAndMetadata>","description":"io.github.nomisRev.kafka.commitAwait","location":"kotlin-kafka/io.github.nomisRev.kafka/commit-await.html","searchKeys":["commitAwait","suspend fun <K, V> KafkaConsumer<K, V>.commitAwait(offsets: Map<TopicPartition, OffsetAndMetadata>): Map<TopicPartition, OffsetAndMetadata>","io.github.nomisRev.kafka.commitAwait"]},{"name":"suspend fun <T> KafkaFuture<T>.await(): T","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun <T> KafkaFuture<T>.await(): T","io.github.nomisRev.kafka.await"]},{"name":"suspend fun Admin.createTopic(topic: Iterable<NewTopic>, option: CreateTopicsOptions = CreateTopicsOptions())","description":"io.github.nomisRev.kafka.createTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/create-topic.html","searchKeys":["createTopic","suspend fun Admin.createTopic(topic: Iterable<NewTopic>, option: CreateTopicsOptions = CreateTopicsOptions())","io.github.nomisRev.kafka.createTopic"]},{"name":"suspend fun Admin.createTopic(topic: NewTopic, option: CreateTopicsOptions = CreateTopicsOptions())","description":"io.github.nomisRev.kafka.createTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/create-topic.html","searchKeys":["createTopic","suspend fun Admin.createTopic(topic: NewTopic, option: CreateTopicsOptions = CreateTopicsOptions())","io.github.nomisRev.kafka.createTopic"]},{"name":"suspend fun Admin.deleteTopic(name: String, options: DeleteTopicsOptions = DeleteTopicsOptions())","description":"io.github.nomisRev.kafka.deleteTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/delete-topic.html","searchKeys":["deleteTopic","suspend fun Admin.deleteTopic(name: String, options: DeleteTopicsOptions = DeleteTopicsOptions())","io.github.nomisRev.kafka.deleteTopic"]},{"name":"suspend fun Admin.describeTopic(name: String, options: DescribeTopicsOptions = DescribeTopicsOptions()): TopicDescription?","description":"io.github.nomisRev.kafka.describeTopic","location":"kotlin-kafka/io.github.nomisRev.kafka/describe-topic.html","searchKeys":["describeTopic","suspend fun Admin.describeTopic(name: String, options: DescribeTopicsOptions = DescribeTopicsOptions()): TopicDescription?","io.github.nomisRev.kafka.describeTopic"]},{"name":"suspend fun Admin.topicExists(topic: NewTopic, listTopicsOptions: ListTopicsOptions = ListTopicsOptions()): Boolean","description":"io.github.nomisRev.kafka.topicExists","location":"kotlin-kafka/io.github.nomisRev.kafka/topic-exists.html","searchKeys":["topicExists","suspend fun Admin.topicExists(topic: NewTopic, listTopicsOptions: ListTopicsOptions = ListTopicsOptions()): Boolean","io.github.nomisRev.kafka.topicExists"]},{"name":"suspend fun CreateTopicsResult.await()","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun CreateTopicsResult.await()","io.github.nomisRev.kafka.await"]},{"name":"suspend fun DeleteTopicsResult.await()","description":"io.github.nomisRev.kafka.await","location":"kotlin-kafka/io.github.nomisRev.kafka/await.html","searchKeys":["await","suspend fun DeleteTopicsResult.await()","io.github.nomisRev.kafka.await"]},{"name":"typealias Acks = io.github.nomisRev.kafka.publisher.Acks","description":"io.github.nomisRev.kafka.Acks","location":"kotlin-kafka/io.github.nomisRev.kafka/-acks/index.html","searchKeys":["Acks","typealias Acks = io.github.nomisRev.kafka.publisher.Acks","io.github.nomisRev.kafka.Acks"]},{"name":"typealias AutoOffsetReset = io.github.nomisRev.kafka.receiver.AutoOffsetReset","description":"io.github.nomisRev.kafka.AutoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka/-auto-offset-reset/index.html","searchKeys":["AutoOffsetReset","typealias AutoOffsetReset = io.github.nomisRev.kafka.receiver.AutoOffsetReset","io.github.nomisRev.kafka.AutoOffsetReset"]},{"name":"val acknowledgments: Acks","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.acknowledgments","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/acknowledgments.html","searchKeys":["acknowledgments","val acknowledgments: Acks","io.github.nomisRev.kafka.publisher.PublisherSettings.acknowledgments"]},{"name":"val acks: Acks","description":"io.github.nomisRev.kafka.ProducerSettings.acks","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/acks.html","searchKeys":["acks","val acks: Acks","io.github.nomisRev.kafka.ProducerSettings.acks"]},{"name":"val autoCommitInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.autoCommitInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/auto-commit-interval.html","searchKeys":["autoCommitInterval","val autoCommitInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.autoCommitInterval"]},{"name":"val autoOffsetReset: AutoOffsetReset","description":"io.github.nomisRev.kafka.ConsumerSettings.autoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/auto-offset-reset.html","searchKeys":["autoOffsetReset","val autoOffsetReset: AutoOffsetReset","io.github.nomisRev.kafka.ConsumerSettings.autoOffsetReset"]},{"name":"val autoOffsetReset: AutoOffsetReset","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.autoOffsetReset","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/auto-offset-reset.html","searchKeys":["autoOffsetReset","val autoOffsetReset: AutoOffsetReset","io.github.nomisRev.kafka.receiver.ReceiverSettings.autoOffsetReset"]},{"name":"val bootstrapServer: String","description":"io.github.nomisRev.kafka.AdminSettings.bootstrapServer","location":"kotlin-kafka/io.github.nomisRev.kafka/-admin-settings/bootstrap-server.html","searchKeys":["bootstrapServer","val bootstrapServer: String","io.github.nomisRev.kafka.AdminSettings.bootstrapServer"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.ConsumerSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.ConsumerSettings.bootstrapServers"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.ProducerSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.ProducerSettings.bootstrapServers"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.publisher.PublisherSettings.bootstrapServers"]},{"name":"val bootstrapServers: String","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.bootstrapServers","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/bootstrap-servers.html","searchKeys":["bootstrapServers","val bootstrapServers: String","io.github.nomisRev.kafka.receiver.ReceiverSettings.bootstrapServers"]},{"name":"val checkCrcs: Boolean = true","description":"io.github.nomisRev.kafka.ConsumerSettings.checkCrcs","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/check-crcs.html","searchKeys":["checkCrcs","val checkCrcs: Boolean = true","io.github.nomisRev.kafka.ConsumerSettings.checkCrcs"]},{"name":"val clientDnsLookup: ClientDnsLookup","description":"io.github.nomisRev.kafka.ConsumerSettings.clientDnsLookup","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/client-dns-lookup.html","searchKeys":["clientDnsLookup","val clientDnsLookup: ClientDnsLookup","io.github.nomisRev.kafka.ConsumerSettings.clientDnsLookup"]},{"name":"val clientId: String","description":"io.github.nomisRev.kafka.ConsumerSettings.clientId","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/client-id.html","searchKeys":["clientId","val clientId: String","io.github.nomisRev.kafka.ConsumerSettings.clientId"]},{"name":"val closeTimeout: Duration","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.closeTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/close-timeout.html","searchKeys":["closeTimeout","val closeTimeout: Duration","io.github.nomisRev.kafka.publisher.PublisherSettings.closeTimeout"]},{"name":"val closeTimeout: Duration","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.closeTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/close-timeout.html","searchKeys":["closeTimeout","val closeTimeout: Duration","io.github.nomisRev.kafka.receiver.ReceiverSettings.closeTimeout"]},{"name":"val commitRetryInterval: Duration","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.commitRetryInterval","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/commit-retry-interval.html","searchKeys":["commitRetryInterval","val commitRetryInterval: Duration","io.github.nomisRev.kafka.receiver.ReceiverSettings.commitRetryInterval"]},{"name":"val commitStrategy: CommitStrategy","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.commitStrategy","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/commit-strategy.html","searchKeys":["commitStrategy","val commitStrategy: CommitStrategy","io.github.nomisRev.kafka.receiver.ReceiverSettings.commitStrategy"]},{"name":"val connectionsMaxIdle: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.connectionsMaxIdle","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/connections-max-idle.html","searchKeys":["connectionsMaxIdle","val connectionsMaxIdle: Duration","io.github.nomisRev.kafka.ConsumerSettings.connectionsMaxIdle"]},{"name":"val createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.createProducer","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/create-producer.html","searchKeys":["createProducer","val createProducer: suspend (PublisherSettings<Key, Value>) -> Producer<Key, Value>","io.github.nomisRev.kafka.publisher.PublisherSettings.createProducer"]},{"name":"val defaultApiTimeout: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.defaultApiTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/default-api-timeout.html","searchKeys":["defaultApiTimeout","val defaultApiTimeout: Duration","io.github.nomisRev.kafka.ConsumerSettings.defaultApiTimeout"]},{"name":"val enableAutoCommit: Boolean = true","description":"io.github.nomisRev.kafka.ConsumerSettings.enableAutoCommit","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/enable-auto-commit.html","searchKeys":["enableAutoCommit","val enableAutoCommit: Boolean = true","io.github.nomisRev.kafka.ConsumerSettings.enableAutoCommit"]},{"name":"val entries: EnumEntries<Acks>","description":"io.github.nomisRev.kafka.publisher.Acks.entries","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/entries.html","searchKeys":["entries","val entries: EnumEntries<Acks>","io.github.nomisRev.kafka.publisher.Acks.entries"]},{"name":"val entries: EnumEntries<AutoOffsetReset>","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.entries","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/entries.html","searchKeys":["entries","val entries: EnumEntries<AutoOffsetReset>","io.github.nomisRev.kafka.receiver.AutoOffsetReset.entries"]},{"name":"val excludeInternalTopics: Boolean","description":"io.github.nomisRev.kafka.ConsumerSettings.excludeInternalTopics","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/exclude-internal-topics.html","searchKeys":["excludeInternalTopics","val excludeInternalTopics: Boolean","io.github.nomisRev.kafka.ConsumerSettings.excludeInternalTopics"]},{"name":"val fetchMaxBytes: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMaxBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-max-bytes.html","searchKeys":["fetchMaxBytes","val fetchMaxBytes: Int","io.github.nomisRev.kafka.ConsumerSettings.fetchMaxBytes"]},{"name":"val fetchMaxWait: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMaxWait","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-max-wait.html","searchKeys":["fetchMaxWait","val fetchMaxWait: Duration","io.github.nomisRev.kafka.ConsumerSettings.fetchMaxWait"]},{"name":"val fetchMinBytes: Int = 1","description":"io.github.nomisRev.kafka.ConsumerSettings.fetchMinBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/fetch-min-bytes.html","searchKeys":["fetchMinBytes","val fetchMinBytes: Int = 1","io.github.nomisRev.kafka.ConsumerSettings.fetchMinBytes"]},{"name":"val groupId: String","description":"io.github.nomisRev.kafka.ConsumerSettings.groupId","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/group-id.html","searchKeys":["groupId","val groupId: String","io.github.nomisRev.kafka.ConsumerSettings.groupId"]},{"name":"val groupId: String","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.groupId","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/group-id.html","searchKeys":["groupId","val groupId: String","io.github.nomisRev.kafka.receiver.ReceiverSettings.groupId"]},{"name":"val heartbeatInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.heartbeatInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/heartbeat-interval.html","searchKeys":["heartbeatInterval","val heartbeatInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.heartbeatInterval"]},{"name":"val interceptorClasses: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.interceptorClasses","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/interceptor-classes.html","searchKeys":["interceptorClasses","val interceptorClasses: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.interceptorClasses"]},{"name":"val interval: Duration","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.interval","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size-or-time/interval.html","searchKeys":["interval","val interval: Duration","io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.interval"]},{"name":"val interval: Duration","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime.interval","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-time/interval.html","searchKeys":["interval","val interval: Duration","io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime.interval"]},{"name":"val isFatal: (t: Throwable) -> Boolean","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.isFatal","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/is-fatal.html","searchKeys":["isFatal","val isFatal: (t: Throwable) -> Boolean","io.github.nomisRev.kafka.publisher.PublisherSettings.isFatal"]},{"name":"val keyDeserializer: Deserializer<K>","description":"io.github.nomisRev.kafka.ConsumerSettings.keyDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/key-deserializer.html","searchKeys":["keyDeserializer","val keyDeserializer: Deserializer<K>","io.github.nomisRev.kafka.ConsumerSettings.keyDeserializer"]},{"name":"val keyDeserializer: Deserializer<K>","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.keyDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/key-deserializer.html","searchKeys":["keyDeserializer","val keyDeserializer: Deserializer<K>","io.github.nomisRev.kafka.receiver.ReceiverSettings.keyDeserializer"]},{"name":"val keyDeserializer: Serializer<K>","description":"io.github.nomisRev.kafka.ProducerSettings.keyDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/key-deserializer.html","searchKeys":["keyDeserializer","val keyDeserializer: Serializer<K>","io.github.nomisRev.kafka.ProducerSettings.keyDeserializer"]},{"name":"val keySerializer: Serializer<Key>","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.keySerializer","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/key-serializer.html","searchKeys":["keySerializer","val keySerializer: Serializer<Key>","io.github.nomisRev.kafka.publisher.PublisherSettings.keySerializer"]},{"name":"val maxCommitAttempts: Int","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.maxCommitAttempts","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/max-commit-attempts.html","searchKeys":["maxCommitAttempts","val maxCommitAttempts: Int","io.github.nomisRev.kafka.receiver.ReceiverSettings.maxCommitAttempts"]},{"name":"val maxDeferredCommits: Int = 0","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.maxDeferredCommits","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/max-deferred-commits.html","searchKeys":["maxDeferredCommits","val maxDeferredCommits: Int = 0","io.github.nomisRev.kafka.receiver.ReceiverSettings.maxDeferredCommits"]},{"name":"val maxPartitionFetchBytes: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPartitionFetchBytes","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-partition-fetch-bytes.html","searchKeys":["maxPartitionFetchBytes","val maxPartitionFetchBytes: Int","io.github.nomisRev.kafka.ConsumerSettings.maxPartitionFetchBytes"]},{"name":"val maxPollInterval: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPollInterval","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-poll-interval.html","searchKeys":["maxPollInterval","val maxPollInterval: Duration","io.github.nomisRev.kafka.ConsumerSettings.maxPollInterval"]},{"name":"val maxPollRecords: Int = 500","description":"io.github.nomisRev.kafka.ConsumerSettings.maxPollRecords","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/max-poll-records.html","searchKeys":["maxPollRecords","val maxPollRecords: Int = 500","io.github.nomisRev.kafka.ConsumerSettings.maxPollRecords"]},{"name":"val metadataMaxAge: Long","description":"io.github.nomisRev.kafka.ConsumerSettings.metadataMaxAge","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metadata-max-age.html","searchKeys":["metadataMaxAge","val metadataMaxAge: Long","io.github.nomisRev.kafka.ConsumerSettings.metadataMaxAge"]},{"name":"val metricsNumSamples: Int = 2","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsNumSamples","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-num-samples.html","searchKeys":["metricsNumSamples","val metricsNumSamples: Int = 2","io.github.nomisRev.kafka.ConsumerSettings.metricsNumSamples"]},{"name":"val metricsRecordingLevel: Sensor.RecordingLevel","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsRecordingLevel","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-recording-level.html","searchKeys":["metricsRecordingLevel","val metricsRecordingLevel: Sensor.RecordingLevel","io.github.nomisRev.kafka.ConsumerSettings.metricsRecordingLevel"]},{"name":"val metricsReporterClasses: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsReporterClasses","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-reporter-classes.html","searchKeys":["metricsReporterClasses","val metricsReporterClasses: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.metricsReporterClasses"]},{"name":"val metricsSampleWindow: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.metricsSampleWindow","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/metrics-sample-window.html","searchKeys":["metricsSampleWindow","val metricsSampleWindow: Duration","io.github.nomisRev.kafka.ConsumerSettings.metricsSampleWindow"]},{"name":"val offset: Offset","description":"io.github.nomisRev.kafka.receiver.ReceiverRecord.offset","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-record/offset.html","searchKeys":["offset","val offset: Offset","io.github.nomisRev.kafka.receiver.ReceiverRecord.offset"]},{"name":"val onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.onPublisherRecordDropped","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/on-publisher-record-dropped.html","searchKeys":["onPublisherRecordDropped","val onPublisherRecordDropped: suspend (Logger, ProducerRecord<Key, Value>) -> Unit","io.github.nomisRev.kafka.publisher.PublisherSettings.onPublisherRecordDropped"]},{"name":"val other: Properties? = null","description":"io.github.nomisRev.kafka.ProducerSettings.other","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/other.html","searchKeys":["other","val other: Properties? = null","io.github.nomisRev.kafka.ProducerSettings.other"]},{"name":"val partitionAssignmentStrategy: List<Class<*>>","description":"io.github.nomisRev.kafka.ConsumerSettings.partitionAssignmentStrategy","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/partition-assignment-strategy.html","searchKeys":["partitionAssignmentStrategy","val partitionAssignmentStrategy: List<Class<*>>","io.github.nomisRev.kafka.ConsumerSettings.partitionAssignmentStrategy"]},{"name":"val pollTimeout: Duration","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.pollTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/poll-timeout.html","searchKeys":["pollTimeout","val pollTimeout: Duration","io.github.nomisRev.kafka.receiver.ReceiverSettings.pollTimeout"]},{"name":"val producerListener: PublisherSettings.ProducerListener","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.producerListener","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/producer-listener.html","searchKeys":["producerListener","val producerListener: PublisherSettings.ProducerListener","io.github.nomisRev.kafka.publisher.PublisherSettings.producerListener"]},{"name":"val properties: Properties","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/properties.html","searchKeys":["properties","val properties: Properties","io.github.nomisRev.kafka.publisher.PublisherSettings.properties"]},{"name":"val properties: Properties","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.properties","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/properties.html","searchKeys":["properties","val properties: Properties","io.github.nomisRev.kafka.receiver.ReceiverSettings.properties"]},{"name":"val receiveBuffer: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.receiveBuffer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/receive-buffer.html","searchKeys":["receiveBuffer","val receiveBuffer: Int","io.github.nomisRev.kafka.ConsumerSettings.receiveBuffer"]},{"name":"val reconnectBackoff: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoff","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/reconnect-backoff.html","searchKeys":["reconnectBackoff","val reconnectBackoff: Duration","io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoff"]},{"name":"val reconnectBackoffMax: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoffMax","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/reconnect-backoff-max.html","searchKeys":["reconnectBackoffMax","val reconnectBackoffMax: Duration","io.github.nomisRev.kafka.ConsumerSettings.reconnectBackoffMax"]},{"name":"val requestTimeout: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.requestTimeout","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/request-timeout.html","searchKeys":["requestTimeout","val requestTimeout: Duration","io.github.nomisRev.kafka.ConsumerSettings.requestTimeout"]},{"name":"val retryBackoff: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.retryBackoff","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/retry-backoff.html","searchKeys":["retryBackoff","val retryBackoff: Duration","io.github.nomisRev.kafka.ConsumerSettings.retryBackoff"]},{"name":"val sendBuffer: Int","description":"io.github.nomisRev.kafka.ConsumerSettings.sendBuffer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/send-buffer.html","searchKeys":["sendBuffer","val sendBuffer: Int","io.github.nomisRev.kafka.ConsumerSettings.sendBuffer"]},{"name":"val sessionTimeOut: Duration","description":"io.github.nomisRev.kafka.ConsumerSettings.sessionTimeOut","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/session-time-out.html","searchKeys":["sessionTimeOut","val sessionTimeOut: Duration","io.github.nomisRev.kafka.ConsumerSettings.sessionTimeOut"]},{"name":"val size: Int","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySize.size","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size/size.html","searchKeys":["size","val size: Int","io.github.nomisRev.kafka.receiver.CommitStrategy.BySize.size"]},{"name":"val size: Int","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.size","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size-or-time/size.html","searchKeys":["size","val size: Int","io.github.nomisRev.kafka.receiver.CommitStrategy.BySizeOrTime.size"]},{"name":"val value: String","description":"io.github.nomisRev.kafka.publisher.Acks.value","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-acks/value.html","searchKeys":["value","val value: String","io.github.nomisRev.kafka.publisher.Acks.value"]},{"name":"val value: String","description":"io.github.nomisRev.kafka.receiver.AutoOffsetReset.value","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-auto-offset-reset/value.html","searchKeys":["value","val value: String","io.github.nomisRev.kafka.receiver.AutoOffsetReset.value"]},{"name":"val valueDeserializer: Deserializer<V>","description":"io.github.nomisRev.kafka.ConsumerSettings.valueDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-consumer-settings/value-deserializer.html","searchKeys":["valueDeserializer","val valueDeserializer: Deserializer<V>","io.github.nomisRev.kafka.ConsumerSettings.valueDeserializer"]},{"name":"val valueDeserializer: Deserializer<V>","description":"io.github.nomisRev.kafka.receiver.ReceiverSettings.valueDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-receiver-settings/value-deserializer.html","searchKeys":["valueDeserializer","val valueDeserializer: Deserializer<V>","io.github.nomisRev.kafka.receiver.ReceiverSettings.valueDeserializer"]},{"name":"val valueDeserializer: Serializer<V>","description":"io.github.nomisRev.kafka.ProducerSettings.valueDeserializer","location":"kotlin-kafka/io.github.nomisRev.kafka/-producer-settings/value-deserializer.html","searchKeys":["valueDeserializer","val valueDeserializer: Serializer<V>","io.github.nomisRev.kafka.ProducerSettings.valueDeserializer"]},{"name":"val valueSerializer: Serializer<Value>","description":"io.github.nomisRev.kafka.publisher.PublisherSettings.valueSerializer","location":"kotlin-kafka/io.github.nomisRev.kafka.publisher/-publisher-settings/value-serializer.html","searchKeys":["valueSerializer","val valueSerializer: Serializer<Value>","io.github.nomisRev.kafka.publisher.PublisherSettings.valueSerializer"]},{"name":"value class BySize(val size: Int) : CommitStrategy","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.BySize","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-size/index.html","searchKeys":["BySize","value class BySize(val size: Int) : CommitStrategy","io.github.nomisRev.kafka.receiver.CommitStrategy.BySize"]},{"name":"value class ByTime(val interval: Duration) : CommitStrategy","description":"io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime","location":"kotlin-kafka/io.github.nomisRev.kafka.receiver/-commit-strategy/-by-time/index.html","searchKeys":["ByTime","value class ByTime(val interval: Duration) : CommitStrategy","io.github.nomisRev.kafka.receiver.CommitStrategy.ByTime"]}]
